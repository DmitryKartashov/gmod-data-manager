--[[------------------------------------------------------------------------
	Модуль с определением различных значений dm_type.type_name
	и логикой загрузки в БД и выгрузки из БД предметов собственности
	игроков с заданым значением поля dm_type.type_name.

	Например:
		dm_type.type_name = 'кухонная утварь'
		Значит, что в этом файле определена логика для загрузки и выгрузки
		любого предмета, который классифицируется как оружие. 
		Эту логику вы определяете сами.

---------------------------------------------------------------------------]]

function dm_new_val(val_name, val_dtype, give_foo, save_foo)
	--[[
		Создает переменную, которая будет храниться в поле dm_item.item_data,
		а также определяет логику загрузки и выгрузки данной переменной.
		Данных переменных можно создать любое количество, лишь бы было, что
		обрабатывать.
		Аргументы:
			val_name: string
				Имя переменной данного типа
			
			val_dtype: string
				Тип данных этой переменной. Это поле - строка.
				здесь вы можете написать что-угодно, лишь бы не забыть,
				зачем нужна эта переменная. Нигде не используется,
				нужна только для удобства.

			give_foo: function
				Функция загрузки переменной.
				Принимает (как посредник) значение из БД и отдает игроку.
				Эта функция не возвращает значений, а лишь только устанавливает
				некоторое значение какой-то характеристики игроку.
				Вызывается при загрузке игрока на сервер.

				Аргументы функции:

				Возвращаемое значение:

			save_foo: function
				Функция выгрузки переменной. 
				Принимает значение от игрока и отдает БД.
				Эта функция возвращает некоторое значение, которое 
				дальше будет записано в БД.
				Вызывается при сохранении данных игрока.

				Аргументы функции:

				Возвращаемое значение:
	]]
	local default_foo = function(arg) return arg end 
	local new_val = {
		['val_name'] = name,
		['val_dtype'] = val_dtype,
		['give_foo'] = not give_foo and default_foo or give_foo,
		['save_foo'] = not save_foo and default_foo or save_foo
	}
	return new_val
end

function dm_new_Type(type_name, values_tbl)
	--[[
		Создает объект класса Type. И загружает его в БД,
		если такого еще нет. 
		Если такой уже есть, то запись в БД произведена не 
		будет и data-manager не сможет рабоать с предметами 
		такого типа. Придумывайте уникальные названия.

		Аргументы:
			type_name: string
				Имя места

			values_tbl: table
				Таблица с переменными, которые будут храниться
				в поле dm_item_item_data. 
				Эти переменные создаются с помощью функции-конструктора
				dm_new_val(...)

	]]
	local default_foo = function(arg) return arg end 
	local new_type = {
		['type_name'] = type_name,
		['values_tbl'] = values_tbl
	}
	loaderDb:add_type(type_name)
	return new_type
end

dm_TYPES = {}

function dm_find_Type(type_name)
	--[[
		Ищет type по имени в таблице dm_TYPES.

		Возвращает таблицу type
	]]
	for k, t in pairs(dm_TYPES) do
		if t.type_name == type_name then
			return t
		end
	end
	return nil
end

